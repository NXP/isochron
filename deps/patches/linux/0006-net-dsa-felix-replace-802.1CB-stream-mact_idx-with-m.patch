From f2286f59b6e0d7c718c1b0475d05f8e6ec4c85d3 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <vladimir.oltean@nxp.com>
Date: Tue, 15 Sep 2020 00:54:04 +0300
Subject: [PATCH 6/7] net: dsa: felix: replace 802.1CB stream mact_idx with mac
 and vid

Let's take the function below.

static void ocelot_prove_mac_table_entries_can_move(struct ocelot *ocelot)
{
	unsigned char mac1[ETH_ALEN] = {0x00, 0x04, 0x9f, 0x63, 0x35, 0xea};
	unsigned char mac2[ETH_ALEN] = {0x00, 0x04, 0x9f, 0x63, 0x35, 0xeb};
	int row, bucket, arbitrary_pgid = 4;
	int vid1 = 102;
	int vid2 = 103;
	int err;

	err = ocelot_mact_learn(ocelot, arbitrary_pgid, mac1, vid1,
				ENTRYTYPE_LOCKED);
	if (err)
		return;

	err = ocelot_mact_lookup(ocelot, mac1, vid1, &row, &bucket);
	if (err)
		return;

	dev_info(ocelot->dev,
		 "Address 1 (mac %pM vid %d) is in MAC table row %d bucket %d\n",
		 mac1, vid1, row, bucket);

	err = ocelot_mact_learn(ocelot, arbitrary_pgid, mac2, vid2,
				ENTRYTYPE_LOCKED);
	if (err)
		return;

	err = ocelot_mact_lookup(ocelot, mac2, vid2, &row, &bucket);
	if (err)
		return;

	dev_info(ocelot->dev,
		 "Address 2 (mac %pM vid %d) is in MAC table row %d bucket %d\n",
		 mac2, vid2, row, bucket);

	err = ocelot_mact_lookup(ocelot, mac1, vid1, &row, &bucket);
	if (err)
		return;

	dev_info(ocelot->dev,
		 "Address 1 (mac %pM vid %d) is in MAC table row %d bucket %d\n",
		 mac1, vid1, row, bucket);
}

What will it print?

Address 1 (mac 00:04:9f:63:35:ea vid 102) is in MAC table row 917 bucket 0
Address 2 (mac 00:04:9f:63:35:eb vid 103) is in MAC table row 917 bucket 0
Address 1 (mac 00:04:9f:63:35:ea vid 102) is in MAC table row 917 bucket 1

What does this mean?

The ROW portion of a FDB entry's position within the MAC table is
statically determined using an 11-bit hash derived from the {DMAC, VID}
key. Within a row, there can be up to 4 buckets, each bucket holding 1
MAC table entry.

But when the hashes of 2 addresses collide and they end up in the same
row (as in the above example, with address 1 = "mac 00:04:9f:63:35:ea
vid 102" and address 2 = "mac 00:04:9f:63:35:eb vid 103"), things don't
happen quite as you might expect. Namely, the second address appears to
be installed by the switch at the same row and bucket as the first
address. So is the first address overwritten? No, it has been moved by
the switch, automatically, to bucket 1.

Let's leave aside for a moment the fact that it's stupid of the hardware
to do that. But the current 802.1CB code has a problem. It makes the
fundamental assumption that the stream IDs have a constant index within
the MAC table, assumption which we proved is false.

To be precise, when a 'tsntool cbstreamidset' with address 2 is run,
it will create in the kernel two streamid structures which both have the
same MAC table index. Then, when one of these streams is configured for
splitting with a command such as 'tsntool cbgen', it will in fact affect
both streams, by calling streamid_multi_forward_set().

The effect of this bug is that, when multiple 802.1CB stream ID rules
are used, stream splitting works with some MAC addresses, but not with
others.

Fix it by making the 802.1CB memorize the MAC and VID instead of the
static MAC table index. The MAC table index will always be looked up by
the driver when something needs to be done with the streams.

Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
---
 drivers/net/dsa/ocelot/felix_tsn.c | 49 ++++++++++++++++--------------
 1 file changed, 26 insertions(+), 23 deletions(-)

diff --git a/drivers/net/dsa/ocelot/felix_tsn.c b/drivers/net/dsa/ocelot/felix_tsn.c
index cd1fb6695eeb..4004d8ff4bef 100644
--- a/drivers/net/dsa/ocelot/felix_tsn.c
+++ b/drivers/net/dsa/ocelot/felix_tsn.c
@@ -59,7 +59,8 @@ struct felix_switch_capa {
 
 struct stream_filter {
 	struct list_head list;
-	u32 mact_idx;
+	unsigned char mac[ETH_ALEN];
+	int vid;
 	u32 index;
 	u8 handle;
 };
@@ -494,7 +495,8 @@ static int felix_qbu_get(struct net_device *ndev, struct tsn_preempt_status *c)
 	return 0;
 }
 
-static int stream_table_add(u32 index, u32 mact_idx, u8 handle)
+static int stream_table_add(u32 index, const unsigned char mac[ETH_ALEN],
+			    int vid, u8 handle)
 {
 	struct stream_filter *stream, *tmp;
 	struct list_head *pos, *q;
@@ -502,7 +504,8 @@ static int stream_table_add(u32 index, u32 mact_idx, u8 handle)
 	list_for_each_safe(pos, q, &streamtable) {
 		tmp = list_entry(pos, struct stream_filter, list);
 		if (tmp->index == index) {
-			tmp->mact_idx = mact_idx;
+			ether_addr_copy(tmp->mac, mac);
+			tmp->vid = vid;
 			tmp->handle = handle;
 			return 0;
 		}
@@ -514,7 +517,8 @@ static int stream_table_add(u32 index, u32 mact_idx, u8 handle)
 		return -ENOMEM;
 
 	stream->index = index;
-	stream->mact_idx = mact_idx;
+	ether_addr_copy(stream->mac, mac);
+	stream->vid = vid;
 	stream->handle = handle;
 	list_add(&stream->list, pos->prev);
 
@@ -575,15 +579,7 @@ static int felix_cb_streamid_set(struct net_device *ndev, u32 index, bool enable
 		if (!stream)
 			return -EINVAL;
 
-		m_index = index / 4;
-		bucket = index % 4;
-
-		ret = ocelot_mact_read(ocelot, m_index, bucket, &dst_idx,
-				       &entry);
-		if (ret)
-			return ret;
-
-		ocelot_mact_forget(ocelot, entry.mac, entry.vid);
+		ocelot_mact_forget(ocelot, stream->mac, stream->vid);
 		stream_table_del(index);
 
 		return 0;
@@ -628,7 +624,7 @@ static int felix_cb_streamid_set(struct net_device *ndev, u32 index, bool enable
 
 		idx = m_index * 4 + bucket;
 
-		return stream_table_add(index, m_index, streamid->handle);
+		return stream_table_add(index, mac, vid, streamid->handle);
 	}
 
 	idx = m_index * 4 + bucket;
@@ -647,7 +643,7 @@ static int felix_cb_streamid_set(struct net_device *ndev, u32 index, bool enable
 
 	ocelot_mact_write(ocelot, dst_idx, &entry, m_index, bucket);
 
-	return stream_table_add(index, idx, streamid->handle);
+	return stream_table_add(index, mac, vid, streamid->handle);
 }
 
 static int felix_cb_streamid_get(struct net_device *ndev, u32 index,
@@ -675,14 +671,18 @@ static int felix_cb_streamid_get(struct net_device *ndev, u32 index,
 	if (!stream)
 		return -EINVAL;
 
-	m_index = stream->mact_idx / 4;
-	bucket =  stream->mact_idx % 4;
-	streamid->type = 1;
+	ret = ocelot_mact_lookup(ocelot, stream->mac, stream->vid,
+				 &m_index, &bucket);
+	if (ret)
+		return ret;
 
+	/* This is done just to retrieve the @dst */
 	ret = ocelot_mact_read(ocelot, m_index, bucket, &dst, &entry);
 	if (ret)
 		return ret;
 
+	streamid->type = 1;
+
 	fwdmask = ocelot_read_rix(ocelot, ANA_PGID_PGID, dst);
 	streamid->ofac_oport = ANA_PGID_PGID_PGID(fwdmask);
 
@@ -698,15 +698,18 @@ static int felix_cb_streamid_get(struct net_device *ndev, u32 index,
 	return 0;
 }
 
-static int streamid_multi_forward_set(struct ocelot *ocelot, u32 index,
-				      u8 fwdmask)
+static int streamid_multi_forward_set(struct ocelot *ocelot,
+				      const unsigned char mac[ETH_ALEN],
+				      int vid, u8 fwdmask)
 {
 	int ret, m_index, bucket, fwdport;
 	struct ocelot_mact_entry entry;
 
-	m_index = index / 4;
-	bucket = index % 4;
+	ret = ocelot_mact_lookup(ocelot, mac, vid, &m_index, &bucket);
+	if (ret)
+		return ret;
 
+	/* This is done just to retrieve the @fwdport */
 	ret = ocelot_mact_read(ocelot, m_index, bucket, &fwdport, &entry);
 	if (ret)
 		return ret;
@@ -1517,7 +1520,7 @@ static int felix_seq_gen_set(struct net_device *ndev, u32 index,
 
 	list_for_each_entry(tmp, &streamtable, list)
 		if (tmp->handle == index)
-			streamid_multi_forward_set(ocelot, tmp->mact_idx,
+			streamid_multi_forward_set(ocelot, tmp->mac, tmp->vid,
 						   split_mask);
 
 	ocelot_write(ocelot,
-- 
2.25.1

